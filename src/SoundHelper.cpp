#if defined(ES8311_AUDIO)

#include "driver/audio/es8311.h"
#include <Audio.h>
#include <vector>
#include <string>
#include "SoundHelper.h"
#include "EEPROMHelper.h"
#include "SkyView.h"
#include "Platform_ESP32.h"
#include <DebugLog.h>

Audio audio; // I2S channel 0 by default
static std::vector<String> fileVector;

static es8311_handle_t es_handle = NULL;
static bool bSoundInitialized = false;

#define SAMPLE_RATE 22050
// too high volume leads to distortion on the tiny speaker
#define DEFAULT_VOICE_VOLUME 80
unsigned long lastSoundMillis = 0;

esp_err_t es8311_codec_init(void) 
{
  es_handle = es8311_create(0, ES8311_ADDRRES_0);
  ESP_RETURN_ON_FALSE(es_handle, ESP_FAIL, "ES8311", "create failed");

  const es8311_clock_config_t es_clk = 
  {
    .mclk_inverted = false,
    .sclk_inverted = false,
    .mclk_from_mclk_pin = true,
    .mclk_frequency = SAMPLE_RATE * 256, // MCLK frequency = 22050 * 256 = ~5.6 MHz
    .sample_frequency = SAMPLE_RATE
  };

  ESP_ERROR_CHECK(es8311_init(es_handle, &es_clk, ES8311_RESOLUTION_16, ES8311_RESOLUTION_16));
  ESP_ERROR_CHECK(es8311_sample_frequency_config(es_handle, es_clk.mclk_frequency, es_clk.sample_frequency));
  ESP_ERROR_CHECK(es8311_microphone_config(es_handle, false));
  ESP_ERROR_CHECK(es8311_voice_volume_set(es_handle, DEFAULT_VOICE_VOLUME, NULL));
  return ESP_OK;
}

bool playFileList(int volume)
{
  if (bSoundInitialized && es_handle != NULL && !fileVector.empty())
  {
    PRINTLN("playFileList: " + String(fileVector.size()) + " files in queue");
    es8311_voice_volume_set(es_handle, volume, NULL);
    return audio.playSDFileList(fileVector);
  }
  return true;
}

bool SetupSound()
{
  bSoundInitialized = false;
  uint8_t cardType = SD_MMC.cardType();
  if (cardType == CARD_NONE)
  {
    PRINTLN("[ERROR] SetupSound skipped, no SD_MMC card found, required for Audio files");
    return false;
  }

  // start I2S & codec
  Serial.println("starting I2S...");

  // set I2S pins for this board
  if (!audio.setPinout(BCLKPIN,WSPIN,DOPIN,-1,MCLKPIN))
  {
    PRINTLN("[ERROR] Failed to set audio pins!");
    return false;
  }
  // DAC init
  if (es8311_codec_init() != ESP_OK)
  {
    PRINTLN("Error initializing ES8311 DAC!");
    return false;
  }
  // set fade in/fade out
  // es8311_voice_fade(es_handle, es8311_fade_t::ES8311_FADE_4LRCK);

  // enable PA
  pinMode(PAPIN, OUTPUT);    // Configure pin 46 (PA) as output
  digitalWrite(PAPIN, HIGH); // Set pin 46 (PA) to HIGH to enable amplifier

  audio.forceMono(true);// Waveshare board has only one speaker, so set to mono

  PRINTLN("I2S and ES8311 DAC initialized!");
   
  bSoundInitialized = true;

  return true;
}

/*
bool play_file(String filename, int volume)
{
  if (bSoundInitialized && audioTaskHandle != NULL)
  {
    PRINTLN("play_file: '" + filename + "'");
    if (!SD_MMC.exists(filename)) 
    {
      Serial.println("play_file: '" + filename + "' does not exist");
      return false;
    }
    es8311_voice_volume_set(es_handle, volume, NULL);
    return audio.connecttoFS(SD_MMC,filename);
  }
  return true;
}
*/

void SoundLoop()
{
  // if not initialized, do nothing
  if (!bSoundInitialized)
  {
    return;
  }

// obsolete, replaced with AudioTask
//  if (audio.isRunning())
//  {
//      audio.loop();
//      vTaskDelay(1);
//      return;
//  }
}

/* add a file to the audio queue, file already checked for existance on SD */
/* note that this method is already protected with the audioMutex */
void add_file(const char* filePath)
{
  // only makes sense if sound was correctly initialized
  if (bSoundInitialized)
  {
    fileVector.push_back(String(filePath));
  }
}

// whenever a danger message is generated by the traffic helper, clear traffic
// advisories from the voice queue, because it can be very slow to process
// those voice messages and we want to alert the pilot asap.
static void ClearSoundQueue()
{
  // only do this is both traffic and alert voice are enabled
  if (settings->voice == VOICE_ON)
  {
    if (xSemaphoreTake(audioMutex, portMAX_DELAY)) 
    {
      for (auto it = fileVector.begin(); it != fileVector.end();)
      {
        // all traffic advisories are done with the slow male voice
        // so if found in the queue, remove them
        if (it->indexOf("/voice1") > 0)
        {
          Serial.println("ClearSoundQueue: remove ='" + *it + "'");
          it = fileVector.erase(it);
        }
        else
        {
          ++it;
        }          
      }
      for (auto it = fileVector.begin(); it != fileVector.end();++it)
      {
        PRINTLN("ClearSoundQueue: Left = '" + *it + "'");
      }
      xSemaphoreGive(audioMutex);
      PRINTLN("resetPlayList");
      audio.resetPlayList();
      vTaskDelay(10);
    }
  }
}

void PlayFileList(bool alarm)
{
  if (alarm)
  {
    ClearSoundQueue();
  }
  // if audio is already running, it will handle the added files
  if (!audio.isRunning())
  {
    // files in the vector?
    if (!fileVector.empty())
    {
      // push the file list into the audio engine
      playFileList(DEFAULT_VOICE_VOLUME);
    }
  }
}

bool IsSoundInitialized()
{
  return bSoundInitialized;
}

/* if defined, print info about audio processing, see Audio lib */
//void audio_info(const char *info)
//{
//    Serial.println(info); Serial.flush();
//}

#endif
